= *$aveNUS - Developer Guide*
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:toclevels: 3
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:icons: font
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-F13-2/main

By: `Team-F13-2`      Since: `Sep 2019`      Licence: `MIT`

== Introduction

$aveNUS is a desktop financial planning app that allows *NUS students* to *plan their meals according
to the amount of budget they set aside per meal* in NUS. With $aveNUS, you can more effectively manage your expenses,
save your favourite meal options within NUS, edit meal options, and even receive recommendations
for meals that suit your budget.

This Developer Guide allows other developers to understand the design principles as well as implementation decisions
behind $aveNUS. With this guide, developers can understand and  contribute to $aveNUS easily.

The table below provides a quick summary of the symbols and formatting used in the guide.

[width="70%",cols="^15%,85%"]
|===
a| `code` | Command that can be typed into the command box
ifndef::env-github[]
a| icon:check[role="green", size="2x"] | Success execution of command
a| icon:lightbulb-o[role="icon-tip", size="2x"] | Tips that might be useful
a| icon:info-circle[role="icon-note", size="2x"] | Additional information that is good to know
a| icon:exclamation-circle[role="icon-important", size="2x"] | Important pointers to take note
endif::[]
|===

== Setting up

:leveloffset: +1

include::SettingUp.adoc[tag=settingup]

:leveloffset: -1

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/savenus/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/savenus/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

//tag::UI[]
[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/savenus/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `FoodListPanel`, `PurchaseListPanel`, `SavingsHistoryPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

There are pop-up windows that appeared when the calls the `InfoCommand` or `HelpCommand` which is a new window with their own stages. The CSS files for each pop-up windows is taken from the `MainWindow` which ensures that they always match the theme of the `MainWindow` should the user decide to switch the theme while either pop-up window is open.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/savenus/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Responds to the user's keyboard and mouse input.
* Pop-up windows respond to the buttons on the menu tab.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.
//end::UI[]

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/savenus/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `SaveNusParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a food item).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/savenus/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Menu data.
* stores the Wallet data.
* stores the Info data.
* stores the SavingsAccount data.
* stores the PurchaseHistory data.
* exposes the `RemainingBudget` and `DaysToExpire` that can be 'observed' e.g. the UI can be bound to these values so that the UI automatically updates when the data in the `Wallet` change.
* exposes the `Savings` that can be 'observed' e.g. the UI can be bound to these values so that the UI automatically updates when the data in the `SavingsAccount` changes.
* exposes an unmodifiable `ObservableList<Food>`, `ObservableList<Savings>` and `ObservableList<Purchase>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in either of the lists change.
* does not depend on any of the other three components.

//tag::food[]
==== Food component in Model

The `Food`,

* stores information on `Name`, `Price` and `Category` which are compulsory fields.
* stores information on `Description`, `Opening Hours` and `Restrictions` which are optional fields.
* stores information `Tag` which are retrieved from the `UniqueTagList`.

.Structure of the Food Component
image:BetterModelClassDiagram.png[]

[NOTE]
As a more OOP model, we can store a `Tag` list in `Menu`, which `Food` can reference.
This would allow `Menu` to only require one `Tag` object per unique `Tag`,
instead of each `Food` needing their own `Tag` object.

==== Design considerations for Food-related Models

When implementing Food-related models, it is important not to add duplicate foods. As the user only requires
to enter the name, price and category as they are compulsory fields, we need to ensure that this does not happen.

For example, you would not want to add Chicken Rice twice into the food list. As a result, our team went through several alternatives
to deal with this consideration.

.Design considerations of the for `Food` model
[cols="50,50"]
|===
|Alternative 1 (Chosen Implementation) |Alternative 2

a|`equals(Food food)` method should rely on Name, and have an additional check for equality of Location, Opening Hours
and Restrictions

* Pros:
** Multiple foods with different Location, Opening Hours and Restrictions are allowed.
** Multiple food with same Price and Category but different Name are also allowed.

* Cons:
** Harder to Implement.

a|`equals(Food food)` method should return true if the foods have same name, price or category.

* Pros:
** Easier Implementation
** Ensures that the compulsory fields are always distinct

* Cons:
** Multiple foods with different Location, Opening Hours and Restrictions are not allowed.
** Multiple foods with same Category or Price are not allowed too.
|===

We chose alternative 1 because there can be multiple instances of `Food` with different `Name` but same `Category`. For
example, an instance of Chicken Rice from a Chinese stall may be different from an instance of Chicken Rice from an Indian
stall. As a result, we would want to be able to add these 2 food items into the food list.
//end::food[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/savenus/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the `Menu` data in json format and read it back.
* can save the `Wallet` data in json format and read it back.
* can save the `PurchaseHistory` data in json format and read it back.
* can save the `SavingsHistory` data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.savenus.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

//tag::sorting[]
=== Sorting feature
The Sorting feature allows users to sort their food items based on certain `FIELD` and `DIRECTION`. The `FIELD` and
`DIRECTION` are as followed:

****
1. `FIELD` : `NAME`, `DESCRIPTION`, `PRICE`, `CATEGORY`, `LOCATION`, `OPENING_HOURS`, `RESTRICTIONS`.
2. `DIRECTION` : `ASC` or `DESC`.
****

[NOTE]
The `FIELD` and `DIRECTION` can be entirely in Upper or Lower Case.

First and foremost, users will be able to sort the food items based on their default ordering.
The default ordering is based on ascending price, name and then category. This is done using the `default` command.+

Not only that, they will be able to implement their own custom comparator using `makesort`. From this, they should be able to use `customsort` and autosort`.  +
`customsort` sorts the food items based on the custom comparator, where `autosort` sorts the food items every time there is an edit to the food list.

==== Classes for sorting feature in Model

The Sorting feature was implemented with a new set of classes introduced to the Model. +

.Sorting class diagram in Sort component.
image::SortingClassDiagram.png[width=500]

From the model, the `CustomSorter` stores the comparator for `autosort` and `makesort`. +

From which, you will need to call `makesort FIELD DIRECTION` to create the custom comparator. The `CustomSorter` contains a `FoodComparator`. +

The `FoodComparator` stores fields which will be needed for various `Food` to be compared.
The `DefaultComparator` helps to sort food items based on their natural ordering. This is called via the `default` command.
When `default` is called, the food list will be sorted according to ascending category, ascending name and ascending price.

Detailed below are the design considerations taken into account when engineering the `DefaultComparator` and `FoodComparator`
classes.

.Design considerations of `
[cols="50,50"]
|===
|Alternative 1 (Chosen Implementation) |Alternative 2

a|`DefaultComparator` should extend from `FoodComparator`

* Pros:
** Duplicate Code is not needed.
** This from of relationship follows Liskov Substitution Principle, as `DefaultComparator` can be easily substituted
by an instance of `FoodComparator`.

* Cons:
** Necessary to specify fields while constructing the `DefaultComparator`.

a|`DefaultComparator` and `FoodComparator` should be standalone classes.

* Pros:
** Both can implement their own `compareTo()` methods.

* Cons:
** This Implementation is wasteful as duplicate code is written.
** Makes it complicated for future developers when they wish to change the `DefaultComparator`.
|===

As a result, we have chosen alternative 1. By specifying the specific fields in the body of constructor in
the `DefaultComparator`, it makes it easier for future developers to create their own form of `DefaultComparator`.
Not only that, it saves time and reduces duplicate code.

==== Creation of new Custom Comparator

The user may wish to create a new custom comparator. This can be done with the `makesort` command.

The sequence diagram for interactions between the Logic, Model and Storage components when a user executes the `makesort` command is shown below.

.Sequence diagram for sample makesort command
image::MakeSortSequenceDiagram.png[]

The user may want to create a new custom comparator. This can be done with the `makesort` command.

The fields are stored in the `FoodComparator` in the CustomSorter object, which stores the necessary fields
as a list.

The current implementation for creating a new `CustomSorter` is done by overwriting the existing `CustomSorter`, with a new
`CustomSorter` with the desired fields.

The command is read as a text string from the command box in the UI and then is executed by calling MainWindow#executeCommand(),
which passes this string (named commandText) to the Logic component by calling Logic#execute(Model model).

The following activity diagram below summarizes how the save command works

.Activity diagram for a sample save command

image::MakeSortActivityDiagram.png[align="center", width="500"]

If fields are given, the original CustomSorter is overridden by a new CustomSorter with new fields. Else, the original
CustomSorter is overridden by a new CustomSorter with no fields.

==== Sorting of the Food list
After the customization of the Custom Comparator, the user can now call the `customsort` command to sort the food items based
on the fields specified. For example, if the fields specified are `PRICE ASC NAME DESC`, the system will sort the food items in order
of ascending price. If two items have the same price, they will be ranked according to their names using lexicographic
comparison.

.Activity diagram for a sample sort command

image::SortingActivityDiagram.png[align="center", width="500"]

If two foods have the same price, they will compared using lexicographical ordering based on their names. If they
are lexicographically similar, their ranks do not change.

.Ranking of food items
|===

|Name |Price ($) |Ranking (Price) | Overall Ranking

|Chicken Rice
|2.80
|2
|2
|Nasi Lemak
|2.80
|2
|3
|Fried Rice
|4.00
|4
|4
|Dim Sum
|1.80
|1
|1

|===

From the table above, we can see Dim Sum will be ranked at the top as it is the cheapest. On the other hand, Fried Rice will
be ranked at the bottom as it is the most expensive food item.

As Chicken Rice and Nasi Lemak have the same price, they will compared
using lexicographical ordering based on their names. Chicken Rice still has a higher ranking than Nasi Lemak as Chicken Rice is
lexicographically smaller than Nasi Lemak.

//end::sorting[]

//tag::savings[]
=== Savings feature
The Savings feature allows users to save a specified amount of money from their wallet into their Savings Account using the `save AMOUNT` command, where `AMOUNT` is a user defined amount of money to deposit into the user's Savings Account.
The Savings feature also allows the user to withdraw from his savings account either into his wallet or withdraw the money completely from the $aveNUS app.
Using the `withdraw AMOUNT`, users will be able to transfer their money into their $aveNUS wallets, and using "withdraw out AMOUNT", the user can withdraw the
money completely from the Savings Account and the application.

==== Classes for savings feature in Model

The Savings feature was implemented with a new set of classes introduced to the Model. The `SavingsAccount` is a singleton class
which contains the methods and  classes related to this feature.
The `SavingsAccount` object is stored in $aveNUS. It exposes a read-only interface `ReadOnlySavings` to allow the other components to retrieve
the savings history of the user while maintaining data integrity.

The `SavingsAccount` contains a unique `SavingsHistory` which contains a list of the past savings and withdrawals made by the user.
which are represented by `Saving` and `Withdrawal` respectively. Both `Saving` and `Withdrawal`
implement AccountMoney object, which consists of 2 objects:

****
1. `Amount` indicated the value added/withdrew and it is displayed in the UI.
2. `TimeStamp` indicated the date and time the amount of money was added/withdrawn.
****

Each `AccountMoney` object is unique because the `TimeStamp` will never be the same. Since it is not possible for the user to do a saving
and a withdrawal at a single time.

.Savings class diagram in Model component.
image::SavingsAccountClassDiagram.png[align=center, alt=SavingsAccount, width=180]

==== Adding to the Savings Account

The user may want to add a new saving to his savings account. This can be done with the `save` command.

The savings/withdrawals are stored in the SavingsAccount in the SavingsHistory object, which stores the savings/withdrawal
as a list.

The current implementation for adding a new saving/withdrawal is done by overwriting the existing SavingsHistory, with a new
SavingsHistory that includes past and new savings/withdrawals.

The command is read as a text string from the command box in the UI and then is executed by calling MainWindow#executeCommand(),
which passes this string (named commandText) to the Logic component by calling Logic#execute(Model model).

The sequence diagram for interactions between the Logic, Model and Storage components when a user executes the `save` command is shown below.

.Sequence diagram for sample save command
image::SaveSequenceDiagram.png[align="center"]

The following activity diagram below summarizes how the save command works

.Activity diagram for a sample save command
image::SaveActivityDiagram.png[align="center", width="400"]
//end::savings[]

//tag::budgeting[]
=== Budget Tracking feature

The Budget Tracking feature allows users to manage their budget for food expenditure.
It keeps the user updated with regards to the amount as well as the duration left for their current budget.
Budget information is also used in the application's recommendation system to suggest appropriate food items within a user's budget.

==== Classes for Budget Tracking feature in Model

The Budget Tracking feature was implemented with the following classes.

.Wallet-related class diagram in Model component.
image::WalletClassDiagram.png[width=400, align="center"]

===== Wallet

****
`Wallet` is a class containing the user's current budget, i.e., storing the user's budget amount and budget duration.
****

===== RemainingBudget

****
`RemainingBudget` stores a user's remaining budget amount.
It contains an `ObservableValue` which allows the UI to track of the amount of money left in the current budget after changes are made to it.
The maximum budget amount has been set to 1 million dollars.

****
[NOTE]
Also, in order to avoid possible loss of precision errors, a `Money` class is used. This design decision is discussed below.

===== DaysToExpire

****
`DaysToExpire` stores a user's remaining budget duration.
It contains an `ObservableValue` which allows the UI to track of the number of days before the current budget expires after changes are made to it.
The maximum budget duration has been set to 1 year (365 days).

When a `DaysToExpire` object is instantiated, it stores the system time as a field.
The budget duration is correspondingly updated based on the difference between this saved time and the actual system time.
****

[NOTE]
Due to development constraints, we have decided to only update the budget duration every time the application is started up instead of constantly monitoring the actual time to update this property.

==== Design considerations for Budget-related models

Below are some design considerations when implementing Budget-related models.

.Design considerations of the for `RemainingBudget` model
[cols="50,50"]
|===
|Alternative 1 (Chosen Implementation) |Alternative 2

a|Creating a `Money` class which makes use of Java's `BigDecimal` class to store budget amount

* Pros:
** Avoid precision loss when adding or subtracting from the budget amount
** `Money` class serves as a reusable class to store money amounts and can be used in other parts of the application such as in the Savings feature

* Cons:
** Increased coupling due to the additional classes used.

a|Making use of Java's primitive `double` to store budget amount

* Pros:
** Easier implementation
** Decreases the number of dependencies of `RemainingBudget`
** Can make use of inbuild `DoubleProperty` to display to GUI

* Cons:
** Loss of precision when adding or subtracting from the budget amount
|===

We chose alternative 1 mainly due to the fact that the loss of precision is extremely apparent to the user.
From our testing, after the user buys 3 or 4 items, the precision error adds up resulting in a difference of 1 cent between the expected and actual budget amount.
This may confuse the user and is a bug that we wish to avoid.

==== Setting a Budget

A budget can be set using the `budget` command which takes a budget amount, and an optional budget duration.

For example, `budget 100 10` will set the user's budget, with $100.00 for 10 days.

The sequence diagram for interactions between the Logic, Model and Storage components when a user executes the `buy 1` command is shown below.

.Sequence diagram for `budget 100 10` command
image::BudgetSequenceDiagram.png[]

The following activity diagram below summarizes how `budget` commands works

.Activity diagram for a `budget` command

image::BudgetActivityDiagram.png[align="center"]
//end::budgeting[]

//tag::purchasing[]
=== Purchase Tracking feature

The Purchase Tracking feature allows users to monitor their food expenditure by keeping track of their purchase history.
Whenever a user's executes the `buy` command, the corresponding food will be added as a purchase to the purchase history.
A user's purchase history is displayed in the UI, similar to the food menu, and is updated every time a change is made to it.

==== Classes for Purchase Tracking feature in Model

.Purchase-related class diagram in Model component.
image::PurchaseHistoryClassDiagram.png[align="center", width=200]

The Purchase Tracking feature was implemented with the following classes.

===== ReadOnlyPurchaseHistory

****
`ReadOnlyPurchaseHistory` is an interface implemented by `PurchaseHistory` to allow the other components to retrieve
the purchase history data of the user while maintaining data integrity.
****

===== PurchaseHistory

****
`PurchaseHistory` contains a `PurchaseHistoryList` and serves as an encapsulation for Purchase-related methods and fields.
****

===== PurchaseHistoryList

****
`PurchaseHistoryList` contains an `ObservableList` of `Purchase` made by the user.
****

===== Purchase

****
`Purchase` contains a `Food` object representing the purchased food item, and a `TimeOfPurchase` representing the time of purchase.
****

===== TimeOfPurchase

****
`TimeOfPurchase` stores the time the `Purchase` was made by the user.
****

==== Buying a Food Item

The user may want to buy a food item and record the purchase. This can be done with the `buy` command.

After the users enters a `buy` command, for example, `buy 1` which buys the first item in the displayed list.

The sequence diagram for interactions between the Logic, Model and Storage components when a user executes the `buy 1` command is shown below.

.Sequence diagram for `buy 1` command
image::BuySequenceDiagram.png[]

The following activity diagram below summarizes how `buy` commands works

.Activity diagram for a `buy` command

image::BuyActivityDiagram.png[width = "300", align="center"]
//end::purchasing[]

//tag::recommendations1[]
=== Recommendation feature

The recommendation feature allows users to generate a list of personalized recommendations using the `recommend` command.
The recommendations are tailored to each user based on the factors below:

****
1. The user's likes and dislikes
2. The user's current budget and date to expiry of budget
3. The user's purchase history
****

Users are able to add their liked and disliked categories, tags and locations into the app using the `like` and `dislike`
command. The recommendation system will then take into account these preferences, in addition to their purchase history,
to generate a more accurate list of recommendations. Users will then able to find the food that they are likely to enjoy
more accurately.

==== Classes for recommendation feature in Model

With the addition of the recommendation feature, a new set of classes were implemented to support the feature.

A singleton class `RecommendationSystem` encapsulates the methods and classes related to this feature.
This `RecommendationSystem` class implements the interface `Recommender` which specifies the behaviour of the system,
and include the ability to generate recommendation values.

Additionally, the `RecommendationSystem` class also contains a class `UserRecommendations`, which include the likes and
dislikes of the user. The functionality of `UserRecommendations` is specified by the `Recommendations` interface,
encompassing the ability to add and remove likes and dislikes, among other features.

The `UserRecommendations` object contain 6 sets, namely:

****
1. A set of user's liked categories
2. A set of user's liked tags
3. A set of user's liked locations
4. A set of user's disliked categories
5. A set of user's disliked tags
6. A set of user's disliked locations
****

The items stored in the sets are first converted to lowercase before adding them so that a case-insensitive
comparison can be done more easily.

The class diagram below illustrates the relationship between the classes.

.Recommendation class diagram in Model component
image::RecommendationClassDiagram.png[width=400, align="center"]

==== Adding likes and dislikes

The feature of adding the user's liked and disliked categories, tags and locations was introduced to support the
recommendation system.

The `UserRecommendations` class stores the list of user likes and dislikes as a set in lowercase to prevent duplicates.
Furthermore, the user's likes and dislikes are integrated with `Storage` for the user's convenience.

The sequence diagram below shows how a sample `like` command is executed:

.Sequence diagram for a sample like command
image::LikeSequenceDiagram.png[align="center"]

The following activity diagram below summarizes how the `like` command works:

.Activity diagram for a sample like command
image::LikeActivityDiagram.png[width=450, align="center"]

A similar execution sequence is performed for a dislike command by replacing instances of like with dislike and vice versa.

==== Displaying recommendations

After customizing the user's likes and dislikes, users can obtain a personalized list of recommendations
using the `recommend` command.
//end::recommendations1[]

Each food is passed to the recommendation system and it calculates the recommendation value based on the tables below:

include::UserGuide.adoc[tag=recommendationbonus]

{empty} +

include::UserGuide.adoc[tag=recommendationpenalty]

//tag::recommendations2[]
The activity diagram below shows how a sample Food is passed into `RecommendationSystem` to output a
recommendation value:

.Activity diagram for `RecommendationSystem#calculateRecommendation`
image::RecValueActivityDiagram.png[width=650, align="center"]

The calculated recommendation values are used to sort the food items when the `recommend` command
is executed. Food with similar recommendation values are sorted based on their price.

==== Design Considerations

Detailed below are the design considerations taken into account when engineering the Recommendation System.

===== Design Considerations of `RecommendationSystem` class

Explained below are our considerations when designing the `RecommendationSystem` class.

.Design considerations of `RecommendationSystem` class
[cols="50, 50"]
|===
|Alternative 1 (Chosen Implementation) |Alternative 2

a|Implement `RecommendationSystem` a singleton class

* Pros:
** Versatile and easy to implement
** Enforces the Singleton property

* Cons:
** Testability of class decreases
** Hidden dependencies are introduced into the class

a|Implement `RecommendationSystem` as a normal class

* Pros:
** Testability of class would be easier

* Cons:
** Hard to bring together the classes required by `RecommendationSystem`
|===

****
We decided to go with alternative 1 and implement `RecommendationSystem` as a singleton because of the fact that it
exists as a global class, encapsulating many seemingly unrelated classes such as `Budget`, `PurchaseHistory` and
`UserRecommendations` in order to produce the required recommendation value.

Implementing `RecommendationSystem` as a singleton would be much simpler than linking together these seemingly
unrelated classes as discussed in alternative 2.

Additionally, there should only be one unique `RecommendationSystem` and `UserRecommendations` in the application due to
our design requirements. To ensure the above requirements are met, we have decided to implement `RecommendationSystem`
as a singleton class.

Furthermore, we have thoroughly tested the implementation of
`RecommendationSystem` and `UserRecommendations` to mitigate the downsides introduced when implementing a singleton.
****

{empty} +

===== Design Considerations of `RecommendationSystem#calculateRecommendation()` function.

Explained below are our considerations when designing the `RecommendationSystem#calculateRecommendation()` function.

.Design considerations of the `RecommendationSystem#calculateRecommendation()` function
[cols="50,50"]
|===
|Alternative 1 (Chosen Implementation) |Alternative 2

a|Declare a static method `calculateRecommendation` to calculate the recommendation value of each `Food`
before sorting them.

* Pros:
** No extra field required for each `Food` item
** Easier implementation and more straightforward

* Cons:
** Sorting by recommendation value may be less efficient as the recommendation system has to calculate the
recommendation value of each `Food` item when the comparator is called

a|Have a field (e.g. `recommendationValue`) for each `Food` item

* Pros:
** Sorting by recommendation value would be more efficient as the recommendation value would
be stored in each item

* Cons:
** The recommendation value of each `Food` must be updated before every command to ensure validity of
the recommendation value
** An extra field `recommendationValue` has to be added to each `Food`
|===

****
We chose alternative 1 because of its simplicity of implementation. Adding a hidden `recommendationValue`
field for each `Food` might not be the best solution in the design of our application. A `recommendationValue` might
not make sense in the context of a `Food` object and thus it may not be justifiable to force a connection between the
two for the sake of efficiency.

Furthermore, we do not have to manually update the recommendation of each `Food` item before every command with this
design.
****
//end::recommendations2[]

=== Alias feature

The alias feature allows users to generate their own unique aliases for commands in $aveNUS. This can be
done using the `alias` command.

==== Classes for alias feature in Model

With the addition of the alias feature, a new set of classes were implemented to support the feature.

A class `AliasList` encapsulates methods and classes related to this feature. It contains a list of
`AliasPair` which stores the alias word, if any, mapped to the command word in the `AliasList`.

Additionally, an `AliasChecker` is implemented to help check the validity of the `AliasPair` in the
`AliasList`. Finally, a `CommandWordAdder` was implemented such that on the creation of a new `AliasList`,
all command words in $aveNUS will have their mapped alias words removed, being replaced by an empty String.

The class diagram below illustrates the relationship between the classes.

.Class Diagram for Alias feature.
image::AliasClassDiagram.png[width=650, align="center"]

==== Mapping an alias word to a command word.

The main command behind the alias feature is `alias`. The user can assign an alias word to a command word
in $aveNUS, as long as the alias word is alphanumeric.

For example, `alias sort s` sets the alias word for the command word `sort` to become `s`.

The sequence diagram below shows how a sample `alias` command is executed.

.Sequence Diagram for sample alias command.
image::AliasSequenceDiagram.png[width=650, align="center"]

The following activity diagram below shows how the `alias` command works.

.Activity Diagram for sample alias command.
image::AliasActivityDiagram.png[width=650, align="center"]

//tag::info[]
=== Info Feature

The info feature allows users to view more information about a particular command. This can be done through calling the
`info` command.

==== Classes for info feature in Model

In order to support the `info` command, new classes were added that correspond to each command in the app.
This is to allow for easy access and also to better organize the information to be displayed for each commands.

These classes only has public fields without any methods as it is only needed by `InfoWindow` to access the information
stored within the class.

The classes added where each class represents an info card:

1. `AddInfo`
2. `AliasInfo`
3. `AutoSortInfo`
4. `BudgetInfo`
5. `BuyInfo`
6. `ClearInfo`
7. `CustomSortInfo`
8. `DefaultInfo`
9. `DeleteInfo`
10. `DislikeInfo`
11. `EditInfo`
12. `ExitInfo`
13. `FilterInfo`
14. `HelpInfo`
15. `HistoryInfo`
16. `InfoInfo`
17. `LikeInfo`
18. `MakeSortInfo`
19. `RecommendInfo`
20. `RemoveDislikeInfo`
21. `RemoveLikeInfo`
22. `SaveInfo`
23. `ShowInfo`
24. `ThemeInfo`
25. `TopUpInfo`
26. `ViewSortInfo`
27. `WithdrawInfo`

[NOTE]
Note that not all the classes that inherit `Command` are included as this info card only concerns the commands
that the users can use.

Each of these classes contains these fields:

. Command Word
. Information
. Usage example
. Expected Output

Each of these fields have to be manually typed as it acts like an in-built user guide for the users who do not have
access to internet connection, but would still like to know about the command.

The class diagram below illustrates the relationship between the classes.

.Info class diagram in Model component
image::InfoClassDiagram.png[]

==== Opening info card about a command

Command word to open up a new `InfoWindow` is `info`. Users are able to view the `InfoWindow` for each and every command
as long as the command exist within the app (There exist the class for such info card in the model).

For example, `info add` will open up a new `InfoWindow` about the command `add`.

The sequence window below shows how a sample `info` command is executed:

.Sequence diagram for sample `info` command
image::InfoSequenceDiagram.png[]

The following activity diagram shows how the `info` command works.

.Activity diagram for sample `info` command
image::InfoActivityDiagram.png[]
//end::info[]

== Documentation

:leveloffset: +1

include::Documentation.adoc[tag=documentation]

:leveloffset: -1

== Testing

:leveloffset: +1

include::Testing.adoc[tag=testing]

:leveloffset: -1

== Dev Ops

:leveloffset: +1

include::DevOps.adoc[tag=devops]

:leveloffset: -1

[appendix]
== Product Scope

*Target user profile*:

* Has a need to manage a significant number of food items
* Has trouble tracking expenditure over a period of time
* Wants to know how much money they have saved
* Wants meal recommendations within their specified budget
* Prefer desktop apps over other types
* Can type fast
* Prefers typing over mouse input
* Reasonably comfortable using CLI apps
* Able to read graphs and data.

*Value proposition*: manage expenditure and get recommendations faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a / an ... |I want to ... |So that I can...

|`* * *` |forgetful user |track my expenditure for the day using the app |know how much I have already spend in the day and plan for the remaining meals of the day.

|`* * *` |greedy user |have reminders when I am about to hit the limits I set for my expenditure |plan my budget better for the weeks ahead.

|`* * *` |meticulous user |sort the food items based on categories |see which items are the best or worst based on certain categories.

|`* * *` |new user |view more information about command |learn how to use the app and its features.

|`* * *` |user |add a food item by specifying the item, price, description and category |update the food items that are available to me if I find new food item options within NUS.

|`* * *` |user |know the total amount I have spent |plan my finances for the remaining days of the month.

|`* * *` |user |only be able to see what I can afford for meals and beverages |save time scrolling through meals that fit my budget.

|`* * *` |user |possess the ability to update existing food entries |update the existing food entries if there are changes in their prices/descriptions.

|`* *` |advanced user |shorten my commands |type faster and more efficiently.

|`* *` |careful user |have a calendar function |keep track of the progress of my spending for the current month

|`* *` |japanese food lover |prioritise Japanese food options over other similarly priced products |find specific food types of our choice/cravings we have.

|`* *` |lazy user |have autocomplete |find food items without having to type long keywords.

|`* *` |lazy user |load and save data from other computers |transfer data to an application onto another desktop.

|`* *` |lazy user |obtain a recommended meal plan according to a specified daily allowance |save the time of having to plan for my meals for the day.

|`* *` |non-tech savvy user |have an easier way to understand how the works eg. through a video |use the app effectively without having to read long user guides.

|`* *` |slow user |a guided tutorial to bring me through the basic functionality of the program |become more familiar with the program before I start using.

|`* *` |smart user |put aliases to the commands available in the application | personalise the app and use it more effectively.

|`* *` |user |add my savings of the month into a customised fund |purchase rewards/gifts/items that I require when I have saved enough for them.

|`* *` |user |know the opening and closing timings of the food stores in NUS |closed shops are not recommended to me to prevent me from wasting time to travel to these shops.

|`* *` |user with dietary/religious restrictions |exclude meals that do not fulfil my dietary requirements |reduce my options to only meals that I can consume.

|`*`|dyslexic user |an app with easy to read font| use the app comfortably with being hindered by my reading disabilities.

|`*` |forgetful user |save specific meal sets to reuse |save time on inputting my meals daily.

|`*` |user |add the birthdays of my friends |set up reminders to buy gifts for my friends.

|`*` |user |receive sample suggestions and examples to understand how to use the program. |understand how to user the application effectively.

|`*` |user who hates travelling | sort places from the nearest to the furthest from my current location| find food places that are easy for me to get to.

|`*` |user who loves to customize things |have a theme changing function of the app from a list of themes available | personalise the app to a theme that I like.

|`*` |user with ADHD |an app with simple commands and UI |use it comfortably without major distractions.
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `Menu` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Add food item

*MSS*

1. User requests to add food item, providing details such as price, description, category, location and so on.
2. $aveNUS adds the food item.
+
Use case ends.

*Extensions*

[none]
* 1a. The details are given in the wrong format or mandatory fields are omitted.
[none]
** 1a1. $aveNUS diplays an error message.
+
Use case resumes at step 1.

[discrete]
=== Use case: Delete food item

*MSS*

1. User requests to delete a specific food item in the observable food list.
2. $aveNUS deletes the food item.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. $aveNUS shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Search food item

*MSS*

1. User requests to search for a food item, providing a search query.
2. $aveNUS shows a list of filtered food items according to their provided query.
+
Use case ends.

*Extensions*

[none]
* 2a. User requests to add food item to their expenditure from the search results.
+
[none]
** 2a1. $aveNUS adds the food item to their expenditure.
+
Use case ends.

* 2b. User requests to search without providing any query.
+
[none]
** 2b1. $aveNUS displays the normal ordering of food items.
+
Use case ends.

[discrete]
=== Use case: Add likes / dislikes

*MSS*

1. User requests to add likes or dislikes, providing the list of liked categories, tags and locations.
2. $aveNUS adds the likes or dislikes into the system.
+
Use case ends.

*Extensions*

[none]
* 1a. The user attempts to add a like that already exists as a dislike, or vice versa.
[none]
** 1a1. $aveNUS shows an error message.
+
Use case ends.

* 1b. The given categories, tags or locations are invalid.
+
[none]
** 1b1. $aveNUS shows an error message.
+
Use case ends.

[discrete]
=== Use case: Display recommendations

*MSS*

1. User requests to list recommendations.
2. $aveNUS shows a list of recommended food items based on their specified budget.
3. User requests to add a specific food item in the list into purchased food items.
4. $aveNUS adds the food item into list of purchased food items.
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. $aveNUS shows an error message.
+
Use case resumes at step 2.


[discrete]
=== Use case: Save money into a savings account

*MSS*

1. User requests to add savings to Savings Account.
2. $aveNUS adds the list of savings in the Savings History display tab.
+
Use case ends.

*Extensions*

[none]
* 1a. The wallet is empty.
+
[none]
** 1a1. $aveNUS shows an error message to tell the user to topup the wallet.
** 1a2. $aveNUS displays Savings History display tab.
** 1a3. $aveNUS displays an empty command box.
+
Use case ends.

[discrete]
=== Use case: Set budget

*MSS*

1. User requests to set budget.
2. $aveNUS calculates the daily budget based on the specified weekly budget.
+
Use case ends.

*Extensions*

[none]
* 1a. The budget set is invalid (such as a negative number).
+
[none]
** 1a1. $aveNUS shows an error message.
+
Use case resumes at step 1.

[appendix]
== Non Functional Requirements

1. Should work on any mainstream OS that has JDK 11 installed.
2. Should be usable by user with novice computing experience.
3. Should be able to respond to user input within 2 seconds.
4. Should be able to run fullscreen without any UI issues.
5. Should be able to read easily by users.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample food items. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a Food Item

. Deleting a Food Item

.. Prerequisites: There has to be a food item in the menu for the user to delete.
.. Test case: `delete 1` +
   Expected: First food item is deleted from the food list. Details of the deleted contact shown in the status message.
.. Test case: `delete 0` +
   Expected: No food item is deleted. Error details shown in the status message.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) +
   Expected: Similar to previous.

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

=== Adding like and dislikes

. Adding likes and dislikes

.. Test case: `like c/chinese t/spicy l/location` +
   Expected: The provided categories, tags and locations are added into the like list. Details of the list of likes
   and dislikes are shown in the status message.
.. Test case: `dislike c/chinese` (after running the above command) +
   Expected: The dislike is not added because the category `chinese` already exists in the user's likes.

=== Removing likes and dislikes

. Removing likes and dislikes

.. Prerequisites: There has to be a like or dislike in the system for the user to remove.
.. Test case: `removelike c/chinese` +
   Expected: The category `chinese` is deleted from the user's likes. Details of the list of likes and dislikes are shown
   in the status message.
.. Test case `removelike c/chinese` (after running the above command) +
   Expected: The command fails because there is no more `chinese` category present in the user's likes.

=== Clearing likes and dislikes

. Clearing likes and dislikes

.. Prerequisites: Optimally, there should be likes or dislikes present in the system for the user to remove.
   However, the command still works even if there are no likes or dislikes present.
.. Test case: `removelike ALL` +
   Expected: All likes are cleared.
.. Test case `removedislike ALL` +
   Expected: All dislikes are cleared.

=== Obtaining a list of recommendations

. Obtaining a list of recommendations

.. Prerequisites: Budget and days to expiry of the budget are set by the user. The budget should also be set high enough
   such that the user is able to purchase food items when the recommendation system calculates the optimal daily budget.
.. Test case: `recommend` +
   Expected: A list of recommendations tailored to the user will appear, taking into account factors such as the user's
   liked and disliked categories, tags and locations and so on. All factors affecting the recommendation system's
   recommendation value are documented in the User Guide and Developer Guide.
